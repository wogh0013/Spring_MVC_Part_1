웹 서버
 - HTTP 기반 동작
 - 정적 리소스 
 - 정적 HTML, CSS, JS, 이미지, 영상
 - ex) NGINX, APACHE

웹 애플리케이션 서버(WAS)
 - HTTP 기반 동작
 - 웹 서버 기능 포함
 - 프로그램 코드 실행 -> 애플리케이션 로직 수행
 - 동적 HTML, HTTP API(JSON), 서블릿, JSP, 스프링 MVC
 - ex) 톰캣

웹 시스템 구성 
             (정적 리소스)
ㅁ ---------- [Web Server] ------------ [WAS] ------------- [DB]
            HTML, CSS, JS      애플리케이션 로짓
                이미지

 - 웹 서버는 잘 안 죽지만, WAS는 잘 죽음
 - WAS와 DB가 죽으면, 웹 서버에서 오류화면 HTML을 제공해줌                


서블릿
 @WebServlet(name = 'helloServlet', urlPatterns = "/hello")
 - urlPatterns의 URL이 호출되면 서블릿 코드가 실행
 - HTTP 요청 정보를 편리하게 사용할 수 있는 HttpServletRequest
 - HTTP 응답 정보를 편리하게 사용할 수 있는 HttpServletResponse
 - 개발자는 HTTP 스펙을 매우 편리하게 사용
 - HTTP 요청 시
   1) WAS는 Request, Response 객체를 새로 만들어서 서블릿 객체 호출
   2) 개발자는 Reqeust 객체에서 HTTP 요청 정보를 꺼내서 편리하게 사용
   3) 개발자는 Response 객체에서 HTTP 응답 정보를 편리하게 입력
   4) WAS는 Response 객체에 담겨있는 내용으로 HTTP 응답 정보 생성
 - 서블릿 컨테이너
   - 서블릿을 지원하는 WAS(ex. 톰캣)
   - 서블릿 객체를 생성-초기화-호출-종료하는 생명주기를 관리
   - 서블릿 객체는 *싱글톤으로 관리
     1) 최초 로딩 시점에 서블릿 객체를 미리 만들고, 고객의 요청이 들어올 때마다 재사용
     2) 모든 고객 요청은 동일한 서블릿 객체 인스턴스에 접근
     3) 공유 변수 사용 주의
     4) 서블릿 컨테이너 종료 시 함께 종료
   - JSP도 서블릿으로 변환되어서 사용    
   - 멀티 쓰레드 지원(동시 요청)

프로세스: 프로그램을 실행하는 것
쓰레드: 프로그램 내부에서 여러 가지 코드를 실행하는 것

쓰레드
 - 애플리케이션 코드를 하나하나 순차적으로 실행하는 것
 - 한 번에 하나의 코드 라인만 수행
 - 동시 처리가 필요하면 쓰레드를 추가 생성
 - 요청마다 쓰레드를 생성하는 것은 비효율적

쓰레드 풀
 - 필요한 쓰레드를 쓰레드 풀에 보관하고 관리
 - 쓰레드 풀에 미리 쓰레드를 생성해놓음
 - 요청이 오면 이미 생성돼있는 쓰레드를 사용 -> 종료되면 쓰레드 풀에 반납
 - 최대 쓰레드를 모두 사용하고 있음 -> 새로 들어오는 요청은 대기 or 거절
 - 요청이 너무 많아도 기존 요청은 안전하게 처리 가능, 응답 시간 빠름 
 - WAS의 주요 튜닝 포인트는 최드 쓰레드 수이다.

백엔드 개발자가 서비스를 제공할 때 생각해야 되는 세 가지
 1. 정적 리소스
  - 고정된 HTML 파일, CSS, JS, 이미지, 영상 등을 제공
  - 주로 웹 브라우저
 2. HTML 페이지
  - 동적으로 필요한 HTML 파일을 생성해서 전달(jsp, 타임리프)
  - 웹 브라우저: HTML 해석                 
 3. HTTP API
  - HTML이 아니라 데이터를 전달
  - 주로 JSON 형식
  - UI 클라이언트 접점(앱 클라이언트, 웹 클라이언트(react, vue), ..)
  - 서버 to 서버(주문 서버 -> 결제 서버)

*SSR(서버 사이드 렌더링)
 - HTML 최종 결과를 '서버'에서 만들어서 웹 브라우저에 전달
 - 주로 정적인 화면에 사용
 - 관련 기술: JSP, 타임리프(백엔드 개발자)

CSR(클라이언트 사이드 렌더링)
 - HTML 결과를 '웹 브라우저'에서 동적으로 생성해서 적용(by 자바스크립트)
 - 주로 동적인 화면에 사용
 - 웹 환경을 필요한 부분만 변경할 수 있음(ex 구글지도)
 - 관련기술: React, Vue.js(프론트엔드 개발자) 

스프링 부트
 - 과거에는 서버에 WAS를 직접 설치, 소스는 War 파일을 만들어서 설치한 WAS에 배포
 - 스프링 부트는 서버를 내장
 - 빌드 결과(Jar)에 WAS 서버 포함 -> 빌드 배포 단순화
 
 ***
 ex)
 절대경로 : action="/save"  localhost:8080/save
 상대경로 : action="save"   localhost:8080/현재 URL 경로/save

 redirect : 클라이언트 -> 서버 -> 클라이언트 -> 서버 (클라이언트가 인지)
 forward : 클라이언트 -> 서버 -> 클라이언트 (클라이언트가 인지X)


MVC 패턴 : 컨트롤러와 뷰라는 영역으로 서로 역할을 나눈 것이다.
1. Controller : HTTP 요청을 받아서 파라미터를 검증하고, 비즈니스 로직을 실행한다.
                그리고 뷰에 전달할 결과 데이터를 조회해서 모델에 담는다.
2. Model : 뷰에 출력할 데이터를 담아둔다. 뷰가 필요한 데이터를 모두 모델에 담아서
           전달해주는 덕분에, 뷰는 비즈니스 로직이나 데이터 접근을 몰라도 되고, 
           화면에 렌더링하는 일에 집중할 수 있다.
3. View : 모델에 담겨있는 데이터를 사용해서 화면을 그리는 일에 집중한다.
          여기서는 HTML을 생성하는 부분을 말한다.


- Model : HttpServletRequest 객체를 사용. request는 내부에 데이터 저장소를 가지고 있음
          request.setAttribute(): 데이터 보관 / request.getAttribute(): 데이터 조회


FrontController 패턴
 - 프론트 컨트롤러 서블릿 하나로 클라이언트의 요청을 받음
 - 프론트 컨트롤러가 요청에 맞는 컨트롤러를 찾아서 호출
 - 입구를 하나로 ! (수문장 역할)
 - 공통 처리 기능
 - 프론트 컨트롤러를 제외한 나머지 컨트롤러는 서블릿을 사용하지 않아도 됨
 - 스프링 웹 MVC의 핵심이 FrontController 이다
 - 스프링 웹 MVC의 DispatcherServlet이 FrontController 패턴으로 구현돼있음

핸들러 어댑터 : 중간에 어댑터 역할을 하는 어댑터 -> 다양한 종류의 컨트롤러 호출 가능
핸들러 : 컨트롤러의 더 넓은 범위 -> 어댑터가 있기 때문에 다양한 것들 처리 가능



--
스프링 MVC 구조
 - 프론트 컨트롤러 => DispatcherServlet
 - 동작 순서
  1. 핸들러 조회 : 핸들러 매핑을 통해 요청 URL에 매핑된 핸들러(컨트롤러)를 조회
  2. 핸들러 어댑터 조회 : 핸들러를 실행할 수 있는 핸들러 어댑터를 조회
  3. 핸들러 어댑터 실행 : 핸들러 어댑터 실행
  4. 핸들러 실행 : 핸들러 어댑터가 실제 핸드러를 실행
  5. ModelAndView 반환 : 핸들러 어댑터는 핸들러가 반환하는 정보를 ModelAndView로 변환해서 반환
  6. viewResolver 호출 : 뷰 리졸버를 찾고 실행
  7. View 반환 : 뷰 리졸버는 뷰의 논리 이름을 물리 이름으로 바꾸고, 렌더링 역할을 담당하는 뷰 객체를 반환
  8. 뷰 렌더링 : View를 통해서 뷰를 렌더링

 - @RequestMapping : 가장 우선순위가 높은 핸들러 매핑과 핸들러 어댑터(애노테이션 기반의 컨트롤러 지원)
  - @GetMapping
  - @PostMapping 으로 변경 가능(더 심플해짐)

@Controller
 1. 스프링이 자동으로 스프링 빈으로 등록(내부에 @Component 애노테이션 존재)
 2. 스프링 MVC에서 애노테이션 기반 컨트롤러로 인식(RequestMappingHandlerMapping)












































































